

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Hello_AlexCc">
  <meta name="keywords" content="Full stack engineer">
  
    <meta name="description" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="温故而知新（JavaScript）">
<meta property="og:url" content="http://yoursite.com/post/%E9%87%8D%E6%B8%A9JavaScript.html">
<meta property="og:site_name" content="Hello_AlexCc">
<meta property="og:description" content="JavaScript">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/js.jpg">
<meta property="article:published_time" content="2023-05-12T10:55:02.000Z">
<meta property="article:modified_time" content="2024-06-11T08:52:17.361Z">
<meta property="article:author" content="Hello_AlexCc">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yoursite.com/img/js.jpg">
  
  
  <title>温故而知新（JavaScript） - Hello_AlexCc</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hello_AlexCc</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/js.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="温故而知新（JavaScript）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-05-12 18:55" pubdate>
        2023年5月12日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      27k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      225 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">温故而知新（JavaScript）</h1>
            
            <div class="markdown-body">
              <h1 id="数据类型-7"><a href="#数据类型-7" class="headerlink" title="数据类型(7)"></a>数据类型(7)</h1><ol>
<li>原始数据类型(6种)<br>a. 数值<br>b. 字符串<br>c. 布尔值<br>d. undefined<br>e. Null<br>f. Symbol（ECMAScript 6 新增）</li>
</ol>
<p>g.任意精度的整数 (BigInt) ，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制</p>
<ol start="2">
<li>引用数据类型<br>a. 对象<br>b. 数组<br>c. 函数<br>…</li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>加减乘除、取模、自增自减</p>
<figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> b;<br><br><span class="hljs-keyword">var</span> sum = (b = a++ + --a) + a-- + b++;<br></code></pre></td></tr></table></figure>


<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<br><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>)<br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-string">&#x27;second&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>concat: 连接两个或多个数组，并返回一个新数组。</p>
<p>join: 将数组中的所有项连接成一个字符串。</p>
<p>pop: 删除并返回数组的最后一项。</p>
<p>push: 在数组的末尾添加一个或多项并返回数组的新长度。</p>
<p>shift: 删除并返回数组的第一项。</p>
<p>unshift: 在数组的开头添加一个或多项。</p>
<p>slice: 返回一个数组的片段，该片段包括开始索引到结束索引（不包括结束索引）的所有项。</p>
<p>splice: 在数组中插入、删除或替换项。</p>
<p>sort: 对数组的所有项进行排序。</p>
<p>reverse: 反转数组中的项的顺序。</p>
<p>indexOf: 返回数组中第一个与给定值匹配的项的索引，如果未找到，则返回 -1。</p>
<p>lastIndexOf: 返回数组中最后一个与给定值匹配的项的索引，如果未找到，则返回 -1。</p>
<p>forEach: 对数组中的每一项执行给定的回调函数。</p>
<p>map: 对数组中的每一项执行给定的回调函数，并返回一个新数组，其中的每一项是回调函数的返回值。</p>
<p>filter: 对数组中的每一项执行给定的回调函数，并返回一个新数组，其中只包含回调函数返回 true 的项。</p>
<p>reduce: 从左到右对数组中的所有项进行累加，并返回单个值。</p>
<p>reduceRight: 从右到左对数组中的所有项进行累加，并返回单个值。</p>
<p>some: 如果数组中至少有一个项通过了给定的测试，则返回 true，否则返回 false。</p>
<p>every: 如果数组中的所有项都通过了给定的测试，则返回 true，否则返回 false。</p>
<h1 id="JS编译原理"><a href="#JS编译原理" class="headerlink" title="JS编译原理"></a>JS编译原理</h1><p>JavaScript 是一种解释型语言，而非编译型语言。这意味着，JavaScript 代码在运行时被动态解释，而不是在编译时预先翻译成机器代码。</p>
<p>在 JavaScript 中，代码会被加载到浏览器或 Node.js 环境中，然后通过 JavaScript 引擎（例如 V8）解释和执行代码。在解释代码之前，JavaScript 引擎会对代码进行词法分析和语法分析，以确定代码的语法正确性和语义。然后，代码将被执行。</p>
<p>总的来说，JavaScript 没有明确的编译过程，但它在加载和运行代码之前经过了词法和语法分析。</p>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析的目的是将 JavaScript 代码的字符串形式转换为一系列词法单元 (tokens)，每个词法单元代表 JavaScript 代码的一个有意义的组成部分，如变量名，运算符，函数等。</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析的目的是将词法单元组合成语法树，语法树代表 JavaScript 代码的结构和语义。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>产生条件</p>
<ol>
<li><p>函数内部有另一个函数</p>
</li>
<li><p>函数内部的函数里面用到了外部函数的局部变量</p>
</li>
<li><p>外部函数将内部函数作为返回值 return 出去了。</p>
</li>
</ol>
<p>好处：</p>
<p>闭包中的变量，充当全局变量使用，减少全局变量的混乱程度。</p>
<p>清除：</p>
<p>将变量设置为 null 即可。</p>
<h1 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h1><p>当我们在代码中使用 new 关键字，它会执行以下操作：</p>
<ul>
<li>创建一个空对象</li>
<li>将该对象的原型链指向构造函数的原型对象</li>
<li>将函数内部的 this 关键字指向新创建的对象</li>
<li>在新创建的对象上执行构造函数中的代码</li>
<li>返回该对象</li>
</ul>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol>
<li><p>普通函数中，谁调用此函数，this 就指向谁。箭头函数中没有自己的this，在哪里定义，或者说箭头函数外部的this指向谁，就是谁。</p>
</li>
<li><p>方法中的this，指向调用方法的对象。</p>
</li>
<li><p>指向全局对象：全局函数中的this</p>
</li>
<li><p>事件中的 this，指向 dom 对象。</p>
</li>
<li><p>构造函数中的 this，指向 new 创建的对象。</p>
</li>
</ol>
<h1 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h1><p>它们的作用都是为了改变 this 的指向</p>
<p>区别是参数不同，第一个参数是想要使用的对象，第二个参数是传递给函数的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> dog = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;is dog&#x27;</span>,<br>  <span class="hljs-title function_">sayName</span>(<span class="hljs-params">name1, name2, name3</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> cat = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;喵喵喵&#x27;</span><br>&#125;<br><br>dog.<span class="hljs-property">sayName</span>.<span class="hljs-title function_">call</span>(cat, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>dog.<span class="hljs-property">sayName</span>.<span class="hljs-title function_">apply</span>(cat, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">const</span> fn = dog.<span class="hljs-property">sayName</span>.<span class="hljs-title function_">bind</span>(cat, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-title function_">fn</span>()<br><br></code></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cat = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;喵喵喵&#x27;</span>,<br>  <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-comment">// 等价于 window 对象调用定时器</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> cat = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;喵喵喵&#x27;</span>,<br>  <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// cat</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// 喵喵喵</span><br>    &#125;)<br>  &#125;<br>&#125;<br><br>cat.<span class="hljs-title function_">sayName</span>()<br></code></pre></td></tr></table></figure>

<h1 id="nextTick-和-setImmediate"><a href="#nextTick-和-setImmediate" class="headerlink" title="nextTick 和 setImmediate"></a>nextTick 和 setImmediate</h1><p>同步代码执行完毕，执行 nextTick，然后是异步代码（setTimeout），最后执行 setImmediate</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>)<br>&#125;)<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;, <span class="hljs-number">0</span>);<br><br><br><span class="hljs-comment">// =&gt;&gt;&gt;&gt;&gt;&gt;  2 1 3 setImmediate</span><br></code></pre></td></tr></table></figure>


<p>setImmediate表示当前事件循环即将结束时，执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>)<br>&#125;)<br><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>&#125;, <span class="hljs-number">0</span>);<br><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br><br><span class="hljs-comment">// =====&gt; 2 6 1 3 5 setImmediate 4(一秒后输出4)</span><br></code></pre></td></tr></table></figure>

<h1 id="宏任务-amp-微任务"><a href="#宏任务-amp-微任务" class="headerlink" title="宏任务&amp;微任务"></a>宏任务&amp;微任务</h1><p>宏任务：计时器、ajax、读取文件</p>
<p>微任务：promise.then</p>
<p>一次事件循环的执行顺序:</p>
<ol>
<li><p>同步程序</p>
</li>
<li><p>process.nextTick</p>
</li>
<li><p>微任务</p>
</li>
<li><p>宏任务</p>
</li>
<li><p>setImmediate</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 当前事件循环最后执行</span><br><span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 宏任务执行完毕之后 微任务执行之前执行</span><br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-comment">// 立即执行</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 立即执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>  <span class="hljs-title function_">r</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 微任务，process.nextTick 执行之后执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<br>&#125;)<br><br><span class="hljs-comment">// 宏任务</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 微任务执行后执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 放到下一次循环中执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 微任务执行后执行</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 立即执行</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br><br><br><span class="hljs-comment">// 2 7 6 1 8 3 5 setImmediate 4</span><br></code></pre></td></tr></table></figure>

<h1 id="浅拷贝、深拷贝"><a href="#浅拷贝、深拷贝" class="headerlink" title="浅拷贝、深拷贝"></a>浅拷贝、深拷贝</h1><p>浅拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;is obj&#x27;</span>,<br>  <span class="hljs-attr">girlfriend</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> o = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, obj)<br><br>obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;is o&#x27;</span><br>obj.<span class="hljs-property">girlfriend</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小花&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br></code></pre></td></tr></table></figure>

<p>深拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;is obj&#x27;</span>,<br>  <span class="hljs-attr">girlfriend</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 如果是基本类型或null，则直接返回</span><br>  &#125;<br><br>  <span class="hljs-keyword">const</span> clone = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      clone[key] = <span class="hljs-title function_">deepClone</span>(obj[key]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="JSON-stringify实现深克隆"><a href="#JSON-stringify实现深克隆" class="headerlink" title="JSON.stringify实现深克隆"></a>JSON.stringify实现深克隆</h1><p>将一个 JSON 对象，转化为字符串，通过 JSON.parse 将字符串转化为对象，从而实现深克隆</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;is obj&#x27;</span>,<br>  <span class="hljs-attr">girlfriend</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o)<br></code></pre></td></tr></table></figure>

<p>JSON.stringify 存在的两个问题：</p>
<ul>
<li>无法拷贝函数、正则表达式、特殊类型的对象（如Date对象）等。</li>
<li>对象中存在循环引用时会导致报错。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如果属性值是 undefined 或者是方法（含箭头函数），克隆出来后，undefined 和函数会丢失</span><br><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) &#123; <span class="hljs-comment">// 方法会丢失</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;is fn&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-attr">reg</span>: <span class="hljs-regexp">/\.js$/ig</span>, <span class="hljs-comment">// 空对象: &#123;&#125;</span><br>  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-comment">// 时间会被计算出来: &quot;2023-05-24T03:07:23.547Z&quot;</span><br>  <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// null</span><br>  <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// 丢失</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hello alexCc&#x27;</span>, <span class="hljs-comment">// &#x27;hello alexCc&#x27;</span><br>  <span class="hljs-attr">s</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]), <span class="hljs-comment">// 空对象: &#123;&#125;</span><br>  <span class="hljs-attr">m</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>() <span class="hljs-comment">// 空对象: &#123;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="structuredClone-实现深克隆"><a href="#structuredClone-实现深克隆" class="headerlink" title="structuredClone 实现深克隆"></a>structuredClone 实现深克隆</h1><p>structuredClone是浏览器提供的一种机制，用于在不同的上下文（例如Web Workers之间）传输和复制可结构化的数据。它是一种用于序列化和反序列化JavaScript对象的算法。</p>
<p>需要注意的是，structuredClone算法是浏览器提供的特性，它并不是JavaScript语言本身的一部分，因此在非浏览器环境中（例如Node.js），无法直接使用structuredClone。</p>
<p>对比 JSON.parse 需要注意的两个问题:</p>
<ul>
<li>对象中存在方法，使用 structuredClone 拷贝会报错，而 JSON.parse 会丢失</li>
<li>structuredClone 支持对象循环引用，JSON.parse 处理循环引用的对象会报错</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-comment">// fn: function (params) &#123; // 会报错</span><br>  <span class="hljs-comment">//     console.log(&#x27;is fn&#x27;)</span><br>  <span class="hljs-comment">// &#125;,</span><br>  <span class="hljs-attr">reg</span>: <span class="hljs-regexp">/\.js$/ig</span>, <span class="hljs-comment">// /\.js$/gi</span><br>  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), <span class="hljs-comment">// Wed May 24 2023 11:23:31 GMT+0800 (中国标准时间) &#123;&#125;</span><br>  <span class="hljs-attr">n</span>: <span class="hljs-literal">null</span>, <span class="hljs-comment">// null</span><br>  <span class="hljs-attr">u</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// undefined</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;hello alexCc&#x27;</span>, <span class="hljs-comment">// &#x27;hello alexCc&#x27;</span><br>  <span class="hljs-attr">s</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]), <span class="hljs-comment">// Set(3) &#123;1, 2, 3&#125;</span><br>  <span class="hljs-attr">m</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>() <span class="hljs-comment">// Map(0) &#123;size: 0&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h1><blockquote>
<p>parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数，radix 是 2-36 之间的整数，表示被解析字符串的基数。</p>
</blockquote>
<p>string: 要被解析的值。</p>
<ul>
<li>如果参数不是一个字符串，则将其转换为字符串 (使用 ToString抽象操作)。</li>
<li>字符串开头的空白符将会被忽略。</li>
</ul>
<h2 id="parseInt-0-0000005-5-为-true"><a href="#parseInt-0-0000005-5-为-true" class="headerlink" title="parseInt (0.0000005) === 5 为 true"></a><strong>parseInt (0.0000005) === 5 为 true</strong></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-number">0.5</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//  &#x27;0.5&#x27;</span><br>(<span class="hljs-number">0.05</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//  &#x27;0.05&#x27;</span><br>(<span class="hljs-number">0.005</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//  &#x27;0.005&#x27;</span><br>(<span class="hljs-number">0.0005</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//  &#x27;0.0005&#x27;</span><br>(<span class="hljs-number">0.00005</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//  &#x27;0.00005&#x27;</span><br>(<span class="hljs-number">0.000005</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//  &#x27;0.000005&#x27;</span><br>(<span class="hljs-number">0.0000005</span>).<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//  &#x27;5e-7&#x27;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>可以发现当数字过小时，toString 输出的结果是科学计数法形式。</li>
<li>parseInt 只能将字符串的前导部分解释为整数值；它忽略任何不能被解释为整数的代码单元，并且不会有忽略指示。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.5</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000005</span>) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>

<h2 id="radix-默认值是-10-吗，何种情况返回值是-NaN？"><a href="#radix-默认值是-10-吗，何种情况返回值是-NaN？" class="headerlink" title="radix 默认值是 10 吗，何种情况返回值是 NaN？"></a>radix 默认值是 10 吗，何种情况返回值是 NaN？</h2><ol>
<li>当 radix 值为 undefined、0 或未指定的，那 JavaScript 会如何处理这种情况:</li>
</ol>
<ul>
<li>如果输入的 string 以 0x 或 0X 开头，那么 radix 会被假定为 16 ，字符串的其他部分按照十六进制来解析。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0x51&#x27;</span>) <span class="hljs-comment">// 5*16^1 + 1*16^0 = 81</span><br></code></pre></td></tr></table></figure></li>
<li>如果输入的 string 以 0 开头，ES5 规定使用十进制，但并非所有的浏览器都支持，因此使用 parseInt 时，需要指定 radix</li>
<li>如果输入的 string 以其他任何值开头，radix 值为 10</li>
</ul>
<ol start="2">
<li>radix 参数的值为 2 ~ 36，当 radix 小于 2 或 大于 36(不包含 0)，返回值为 NaN</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">38</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123&quot;</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>待转换字符串中，所有的可转换数字都不小于 radix 值</li>
</ol>
<p>例如 radix 值为 2 (二进制)，而待转换字符串为 ‘3456’，二进制内只有 0、1 是基本算符，因此字符串 ‘3456’ 无法转换成二进制，返回值为 NaN。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;3456&quot;</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;45px&quot;</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure>

<h2 id="‘1’-‘2’-‘3’-map-parseInt"><a href="#‘1’-‘2’-‘3’-map-parseInt" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt)"></a>[‘1’, ‘2’, ‘3’].map(parseInt)</h2><blockquote>
<p>[parseInt(“1”, 0), parseInt(“2”, 1), parseInt(“3”, 2)]</p>
</blockquote>
<ul>
<li><p>parseInt(“1”, 0)<br>radix 为 0，且 string 以字符 1 开始，radix 值为 10，值为 1。</p>
</li>
<li><p>parseInt(“2”, 1)<br>符合 2.2 ，radix 小于 2，返回 NaN</p>
</li>
<li><p>parseInt(“3”, 2)<br>待转换字符串中，所有的可转换数字大于 radix 值，返回 NaN</p>
</li>
</ul>
<h1 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h1><ul>
<li><p>GUI渲染线程</p>
<ul>
<li>负责渲染页面，布局和绘制</li>
<li>页面需要重绘和回流时，该线程就会执行</li>
<li>与js引擎线程互斥，防止渲染结果不可预期</li>
</ul>
</li>
<li><p>JS引擎线程</p>
<ul>
<li>负责处理解析和执行javascript脚本程序</li>
<li>只有一个JS引擎线程（单线程）</li>
<li>与GUI渲染线程互斥，防止渲染结果不可预期</li>
</ul>
</li>
<li><p>事件触发线程</p>
<ul>
<li>用来控制事件循环（鼠标点击、setTimeout、ajax等）</li>
<li>当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</li>
</ul>
</li>
<li><p>定时触发器线程</p>
<ul>
<li>setInterval与setTimeout所在的线程</li>
<li>定时任务并不是由JS引擎计时的，是由定时触发线程来计时的</li>
<li>计时完毕后，通知事件触发线程</li>
</ul>
</li>
</ul>
<ul>
<li>异步http请求线程<ul>
<li>浏览器有一个单独的线程用于处理AJAX请求</li>
<li>当请求完成时，若有回调函数，通知事件触发线程</li>
</ul>
</li>
</ul>
<h1 id="为什么-javascript-是单线程的"><a href="#为什么-javascript-是单线程的" class="headerlink" title="为什么 javascript 是单线程的?"></a>为什么 javascript 是单线程的?</h1><p>首先是历史原因，在创建 javascript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。</p>
<p>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。</p>
<p>而且，如果同时操作 DOM ，在多线程不加锁的情况下，最终会导致 DOM 渲染的结果不可预期。</p>
<h1 id="为什么-GUI-渲染线程与-JS-引擎线程互斥"><a href="#为什么-GUI-渲染线程与-JS-引擎线程互斥" class="headerlink" title="为什么 GUI 渲染线程与 JS 引擎线程互斥?"></a>为什么 GUI 渲染线程与 JS 引擎线程互斥?</h1><p>这是由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS线程和UI线程同时运行)，<br>那么渲染线程前后获得的元素就可能不一致了。</p>
<p>因此，为了防止渲染出现不可预期的结果，浏览器设定 GUI渲染线程和JS引擎线程为互斥关系，<br>当JS引擎线程执行时GUI渲染线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行。</p>
<h1 id="如何理解-JS-的运行机制（Event-Loop）"><a href="#如何理解-JS-的运行机制（Event-Loop）" class="headerlink" title="如何理解 JS 的运行机制（Event Loop）?"></a>如何理解 JS 的运行机制（Event Loop）?</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903919789801486">https://juejin.cn/post/6844903919789801486</a></p>
</blockquote>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ol>
<li>JS分为同步任务和异步任务</li>
<li>同步任务都在 <code>JS 引擎线程</code> 上执行，形成一个执行栈</li>
<li><code>事件触发线程</code> 管理一个任务队里，异步任务触发条件达成，将回调事件放入执行栈中执行</li>
<li>执行栈中所有同步任务执行完毕，此时JS引擎线程空闲，系统会读取任务队列，将可运行的异步任务回调事件添加到执行栈中，开始执行</li>
</ol>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><ol>
<li>执行一个宏任务（栈中没有，就从任务队列中获取）</li>
<li>执行过程中如果遇到了微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕，立即执行微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后 GUI 渲染线程接管，开始渲染</li>
<li>渲染完毕后，JS 线程接管，开始下一个宏任务（从任务队列中获取）</li>
</ol>
<img src="/img/event loop.jpg" srcset="/img/loading.gif" lazyload />

<h1 id="var-和-let-的区别"><a href="#var-和-let-的区别" class="headerlink" title="var 和 let 的区别"></a>var 和 let 的区别</h1><ol>
<li>var 声明的变量，其作用域为当前函数、模块或全局；let 声明的变量，其作用域总是在当前的代码块，例如语句块。</li>
<li>在同一个代码块中，var可以多次声明变量名；let只能声明一次，覆盖一个已经声明的 let 变量会导致语法错误。</li>
<li>用户可以在声明语句之前使用 var 变量，其值是 undefined. 而 let 必须先声明后使用。</li>
<li>全局模块下，var 声明的变量作为global上的属性，let声明的变量则不是 global上的属性，而是作为全局模块中的标识符。</li>
</ol>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><ul>
<li>引用计数：被引用，则计数+1，不再引用，计数减一。存在循环引用问题。</li>
<li>标记清除（常用）：当变量进入到执行环境，则标记上已进入执行环境，当执行完成后，变量离开执行环境则标记已离开执行环境。</li>
</ul>
<h1 id="原型链-amp-继承"><a href="#原型链-amp-继承" class="headerlink" title="原型链 &amp; 继承"></a>原型链 &amp; 继承</h1><p>每个构造函数都有一个原型对象（prototype），原型有一个属性（constructor）指回构造函数，而实例有一个内部指针（<strong>proto</strong>）指向原型。</p>
<p>原型链最顶端是 null</p>
<p>任何函数的默认原型都是一个Object的实例，这意味着这个实例有一个内部指针指向Object.prototype。</p>
<p>这也是为什么自定义类型能够继承包括toString()、valueOf()在内的所有默认方法的原因</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">params</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(params)<br>&#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1</span>)<br><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span> &gt;&gt;&gt; <span class="hljs-literal">true</span><br><br>p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &gt;&gt;&gt; <span class="hljs-literal">true</span><br><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &gt;&gt;&gt; <span class="hljs-literal">true</span><br><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span> &gt;&gt;&gt; <span class="hljs-literal">true</span><br><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<h2 id="原型与继承的关系"><a href="#原型与继承的关系" class="headerlink" title="原型与继承的关系"></a>原型与继承的关系</h2><p>原型与实例的关系可以通过<code>两种</code>方式来确定。</p>
<p>第一种方式是使用<code>instanceof操作符</code>，<strong>如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">o <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">// true 实例的原型链中出现过相应的构造函数</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">instance_of</span>(<span class="hljs-params">instance, obj</span>) &#123;<br>  <span class="hljs-keyword">let</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(instance)<br><br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (prototype === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">if</span> (prototype === obj.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(prototype)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第二种方式是使用<code>isPrototypeOf()</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(o)<br></code></pre></td></tr></table></figure>

<h2 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h2><p>问题一：原型中包含的引用值会在所有实例间共享</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Sub</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>() <span class="hljs-comment">// Super 实例的属性值，变成了 Sub 原型对象上的属性</span><br><br><span class="hljs-keyword">const</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br><br>o1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>)<br><br><span class="hljs-comment">// 所有实例共享原型对象上的 colors</span><br><span class="hljs-keyword">const</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o2.<span class="hljs-property">colors</span>) <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;black&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>问题二：子类型在实例化时不能给父类型的构造函数传参</p>
<h2 id="盗用构造函数继承"><a href="#盗用构造函数继承" class="headerlink" title="盗用构造函数继承"></a>盗用构造函数继承</h2><blockquote>
<p>为了解决原型包含引用值导致的继承问题</p>
</blockquote>
<p>在子类构造函数中调用父类构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Super</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 实例化 Sub 时，给每个 Sub 实例上都复制（拷贝）一份 colors，实例间不共享 colors，都有属于自己的那一份 colors</span><br>  <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br>o1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;black&#x27;</span>)<br><br><span class="hljs-keyword">const</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o2.<span class="hljs-property">colors</span>) <span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;]</span><br></code></pre></td></tr></table></figure>

<p>也可以给父类传递参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Sub</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Super</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&#x27;Hello world&#x27;</span>)<br><br>  <span class="hljs-comment">// 这里可以额外添加属性</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>盗用构造函数也是有缺点的：</p>
<ol>
<li>不是原型链继承，无法使用父类原型对象上的属性和方法。</li>
<li>父类上定义的所有属性和方法，都会被复制到子类实例上，如果属性和方法太多，占用内存就会较大。并且继承的目的是为了属性和方法的<code>复用</code>，而且借用构造函数是将父类定义的方法和属性进行了<code>复制</code>。</li>
</ol>
<h2 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h2><blockquote>
<p>综合了原型链和借用构造函数</p>
</blockquote>
<p>基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) &#123;<br><br>  <span class="hljs-comment">// 借用构造函数</span><br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">19</span><br>&#125;<br><br><span class="hljs-comment">// 原型链继承</span><br><span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><br><span class="hljs-keyword">const</span> u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u.<span class="hljs-title function_">sayName</span>())<br></code></pre></td></tr></table></figure>

<p>组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承模式。而且组合继承也保留了 <code>instanceof操作符</code> 和 <code>isPrototypeOf()</code> 方法识别合成对象的能力。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">User</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(u <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(u))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(u))<br></code></pre></td></tr></table></figure>

<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><blockquote>
<p>创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ECMAScript 5通过增加<code>Object.create()</code>方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选: Object.defineProperties()）。在只有一个参数时，Object.create()与这里的object()方法效果相同。</p>
<p>在 <code>组合式继承</code>中，我们可以将原型链继承那部分可以改写一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br></code></pre></td></tr></table></figure>

<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><blockquote>
<p>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">original</span>)&#123;<br>  <span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original) <span class="hljs-comment">// 通过调用函数创建一个新对象</span><br><br>  clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 以某种方式增强这个对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="寄生式组合继承-继承的最佳模式"><a href="#寄生式组合继承-继承的最佳模式" class="headerlink" title="寄生式组合继承(继承的最佳模式)"></a>寄生式组合继承(继承的最佳模式)</h2><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>)&#123;<br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);   <span class="hljs-comment">//第二次调用SuperType()</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=<span class="hljs-title function_">newSuperType</span>();   <span class="hljs-comment">//第一次调用SuperType()</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">SubType</span>;<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>有两组name和colors属性：一组在实例上，另一组在SubType的原型上。</p>
<img src="/img/组合继承.jpg" srcset="/img/loading.gif" lazyload />

<blockquote>
<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。</p>
</blockquote>
<p>说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>  <span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// 将superType.prototype作为新对象的原型对象</span><br><br>  prototype.<span class="hljs-property">constructor</span> = subType <span class="hljs-comment">// 增强对象</span><br><br>  subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype<span class="hljs-comment">// 新对象赋值给子类原型</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来改写 <code>组合继承</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>, <span class="hljs-title class_">SuperType</span>);<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里只调用了一次SuperType构造函数，避免了SubType.prototype上不必要也用不到的属性，因此可以说这个例子的效率更高。</p>
<p>而且，原型链仍然保持不变，因此instanceof操作符和isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型<code>继承的最佳模式</code>。</p>
<h2 id="ES6-class-的-extends-关键字"><a href="#ES6-class-的-extends-关键字" class="headerlink" title="ES6 class 的 extends 关键字"></a>ES6 class 的 extends 关键字</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Point</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x, y, color</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(x, y) <span class="hljs-comment">// 必须调用 super (父类的 this 对象)</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类调用，称为“静态方法”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;static&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">staticMethod</span>()<br></code></pre></td></tr></table></figure>

<p>父类的静态方法可以被子类继承。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Foo</span> &#123;&#125;<br><br><span class="hljs-title class_">Bar</span>.<span class="hljs-title function_">staticMethod</span>() <span class="hljs-comment">// static</span><br></code></pre></td></tr></table></figure>

<p>父类的静态方法可以在子类中通过 <code>super</code> 关键字调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Foo</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">say</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">staticMethod</span>() + <span class="hljs-string">&#x27; method&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">Bar</span>.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// static method</span><br></code></pre></td></tr></table></figure>

<h1 id="class-和构造函数有什么区别？"><a href="#class-和构造函数有什么区别？" class="headerlink" title="class 和构造函数有什么区别？"></a>class 和构造函数有什么区别？</h1><ol>
<li><p>类必须使用new调用，直接调用会报错</p>
</li>
<li><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。</p>
</li>
<li><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>
</li>
<li><p>类的内部所有定义的方法，都是不可枚举的</p>
</li>
<li><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。</p>
<p> 这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>
</li>
</ol>
<p>super作为函数调用时，代表父类的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span> &#123; <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">super</span>() &#125;&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p>
<p><strong>继承区别</strong></p>
<ol>
<li>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面 Parent.call(this)</li>
</ol>
<ol start="2">
<li>ES6 的继承机制，实质是先将父类实例对象的属性和方法加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</li>
</ol>
<h1 id="防抖-amp-节流"><a href="#防抖-amp-节流" class="headerlink" title="防抖&amp;节流"></a>防抖&amp;节流</h1><p>防抖：用户触发事件频繁，只需要用户最后一次操作的结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input&#x27;</span>)<br><span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br><br>input.<span class="hljs-property">oninput</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">if</span> (timer !== <span class="hljs-literal">null</span>) &#123;<br>    timer = <span class="hljs-built_in">clearTimeout</span>(timer)<br>  &#125;<br><br>  timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>封装防抖函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">500</span></span>) &#123;<br>  <span class="hljs-comment">// 闭包</span><br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span><br>  <span class="hljs-comment">// this ===&gt; window</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// this ===&gt; input</span><br>    <span class="hljs-keyword">if</span> (timer !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer)<br>    &#125;<br><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>    &#125;, delay);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#input&#x27;</span>)<br><br>input.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;value: &#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>&#125;, <span class="hljs-number">800</span>)<br></code></pre></td></tr></table></figure>

<p>节流：控制事件执行的次数，每个多少时间间隔执行一次。</p>
<p>比如监听滚动条的触发事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - time &gt; <span class="hljs-number">1000</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行&#x27;</span>)<br>    time = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>封装节流函数 throttle</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> time = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">if</span> (now - time &gt; delay) &#123;<br>      fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>      time = now<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><ol>
<li>函数的返回结果只依赖于它的参数，相同的输入始终得到相同的输出。</li>
<li>函数执行过程中没有副作用（不改变、不依赖外部任何可观察的变化）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<h2 id="可缓存的纯函数"><a href="#可缓存的纯函数" class="headerlink" title="可缓存的纯函数"></a>可缓存的纯函数</h2><p>当我们的计算量非常大，可能耗时很长或者很好性能，那么我们通过缓存的方式，避免函数多次计算。从而，计算了一次之后，以后再输入相同的参数，就直接返回上次计算的结果。</p>
<blockquote>
<p>lodash.memozie(add, resolver)</p>
</blockquote>
<p>实现 memoize 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;计算中...&#x27;</span>)<br><br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">resolver</span> = (<span class="hljs-params">...args</span>) =&gt; <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">func, resolver</span>) &#123;<br>  <span class="hljs-keyword">const</span> cache = &#123;&#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> key = <span class="hljs-title function_">resolver</span>(...args) <span class="hljs-comment">// &quot;[a, b]&quot;</span><br><br>    <span class="hljs-keyword">if</span> (cache[key]) &#123;<br>      <span class="hljs-keyword">return</span> cache[key]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> cache[key] = <span class="hljs-title function_">func</span>(...args)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> memoized = <span class="hljs-title function_">memoize</span>(add, resolver)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoized</span>(<span class="hljs-number">9</span>, <span class="hljs-number">9</span>)) <span class="hljs-comment">// 第一次打印 &quot;计算中...&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoized</span>(<span class="hljs-number">9</span>, <span class="hljs-number">9</span>)) <span class="hljs-comment">// 不会打印</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoized</span>(<span class="hljs-number">9</span>, <span class="hljs-number">9</span>)) <span class="hljs-comment">// 不会打印</span><br></code></pre></td></tr></table></figure>


<h1 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h1><p>给一个函数传入一部分参数，让其返回的函数接收剩余的参数。直到所有的参数都给到了，才会计算结果。</p>
<blockquote>
<p>lodash.curry(fn)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b + c<br>&#125;<br><br><span class="hljs-keyword">const</span> fn = lodash.<span class="hljs-title function_">curry</span>(add)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure>

<p>实现 curry 函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) &#123;<br>  <span class="hljs-keyword">const</span> curried = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 函数的length 表示它有几个参数</span><br>    <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &lt; func.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-comment">// 累加参数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> <span class="hljs-title function_">curried</span>(...args, ...rest)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 传入的参数和方法接收的参数相同，直接执行 func 函数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(...args)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> curried<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b + c<br>&#125;<br><br><span class="hljs-keyword">const</span> curried = <span class="hljs-title function_">curry</span>(add)<br><span class="hljs-keyword">const</span> fn = <span class="hljs-title function_">curried</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure>

<h1 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h1><p>看个例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello &#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#x27;wor&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add2</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#x27;l&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add3</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#x27;d&#x27;</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add3</span>(<span class="hljs-title function_">add2</span>(<span class="hljs-title function_">add1</span>(str)))) <span class="hljs-comment">// hello wrold</span><br><br></code></pre></td></tr></table></figure>

<p>我们通过手动组合的方式，将每个函数的结果拼接了起来，能实现想要的结果，但是过于繁琐，假设还有几个函数或者十几个函数，恐怕写下去人都麻了。</p>
<p>好在 lodash 这个库也帮我们实现了这个方法 <code>flow &amp; flowRight</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> f = lodash.<span class="hljs-title function_">flow</span>(add1, add2, add3)<br><br><span class="hljs-title function_">f</span>(str)<br></code></pre></td></tr></table></figure>

<p>手动实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello - &#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#x27;wor&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add2</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#x27;l&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add3</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str + <span class="hljs-string">&#x27;d&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// console.log(add3(add2(add1(str))))</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flow</span>(<span class="hljs-params">...fns</span>) &#123;<br>  <span class="hljs-keyword">if</span> (fns.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> fns[<span class="hljs-number">0</span>]<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> fns.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 从右往左</span><br>    <span class="hljs-comment">// 第一步 a === add3, b === add2</span><br>    <span class="hljs-comment">// 第二步 a === (...args) =&gt; add3(add2(...args)), b === add1</span><br>    <span class="hljs-comment">// 第二步的 a 显示为 (...args) =&gt; a(b(...args))</span><br>    <span class="hljs-comment">// 返回 a(add1(...args))</span><br><br>    <span class="hljs-comment">// 当我们最后调用 f 时，会先计算 add1(...args)，拿到结果后，执行 a &quot;add3(add2(add1(...args)))&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args))<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> f = <span class="hljs-title function_">flow</span>(add1, add2, add3)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">f</span>(str))<br></code></pre></td></tr></table></figure>

<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><blockquote>
<p>什么是跨域？</p>
<p>CORS 全称是 Cross-Origin Resource Sharing，意为跨域资源共享。当一个资源去访问另一个不同域名或者不同端口的资源时，就会发出跨域请求。如果另一个资源不允许其进行跨域资源访问，就会造成跨域。 </p>
</blockquote>
<p><strong>跨域不是问题，是浏览器的安全机制</strong></p>
<p>跨域不会阻止请求的发出，也不会阻止请求的接收，跨域是浏览器为了保护当前页面，你的请求得到了响应，但是浏览器不会将请求到的数据提交给当前页面上的回调，取而代之的是去提示你这是一个跨域数据。</p>
<p><strong>同源策略</strong>导致。</p>
<p>所谓同源策略，就是<code>协议、域名、端口号</code>都要相同，有一个不相同，那么就是非同源，就会出现跨域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 跨域(端口不同)</span><br><br><span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:8080</span><br><span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:3000</span><br><br><br><span class="hljs-comment">// 跨域(协议不同)</span><br><span class="hljs-attr">https</span>:<span class="hljs-comment">//localhost:8080</span><br><span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost:8080</span><br><br><span class="hljs-comment">// 跨域(域名)</span><br><span class="hljs-attr">https</span>:<span class="hljs-comment">//localhost:8080</span><br><span class="hljs-attr">https</span>:<span class="hljs-comment">//192.168.1.2:8080</span><br><br><br><span class="hljs-comment">// 跨域(协议不同，端口也不同)</span><br><span class="hljs-comment">// http 默认端口是 80，https 默认端口是 443</span><br><span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost/bbb</span><br><span class="hljs-attr">https</span>:<span class="hljs-comment">//localhost/aaa</span><br></code></pre></td></tr></table></figure>

<h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><ol>
<li>纯后端方式</li>
</ol>
<p>假设我们有个后端服务 3000，提供了 <code>/user</code> 接口，我们可以直接在 <code>.html</code> 文件中访问，如果后端不设置跨域，那么肯定会出现跨域提示的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// server</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;请求user成功&#x27;</span><br>  &#125;)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;3000&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at port 3000...&#x27;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// client</span><br>&lt;script&gt;<br>  <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:3000/user&#x27;</span>)<br>  xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">consolelog</span>(xhr.<span class="hljs-property">response</span>)<br>  &#125;<br>  xhr.<span class="hljs-title function_">send</span>()<br><br><br>  <span class="hljs-comment">// fetch</span><br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/user&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">text</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p><strong>后端设置跨域访问</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// CORS</span><br>app.<span class="hljs-title function_">all</span>(<span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  <span class="hljs-comment">// 允许所有请求源</span><br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>)<br><br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>前端处理<br>主要是通过 <code>webpack devServer</code> 的 <code>proxy</code> 来处理。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">...<br><span class="hljs-attr">devServer</span>: &#123;<br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/&#x27;</span> <span class="hljs-comment">// http://localhost:8080/api/user =&gt; http://localhost:3000/api/user</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">proxy</span>: &#123;<br>    <span class="hljs-string">&#x27;/no-api&#x27;</span>: &#123;<br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000/&#x27;</span>, <span class="hljs-comment">// http://localhost:8080/no-api/user =&gt; http://localhost:3000/user</span><br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&#x27;/no-api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 后端接口中一般不会含有 api 标识符，我们可以去掉</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>&#125;<br>...<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>Nginx</li>
</ol>
<p>要注意的是，devServer 配置 proxy 只是存在于我们开发项目时有用，如果项目要上线，devServer 就没有了，这时可以考虑采用 <code>Nginx</code> 来代理。</p>
<ol start="4">
<li>前后端合并方式</li>
</ol>
<p>我们可以不采用 <code>devServer proxy</code> 方式，而是在后端配置 <code>webpack-dev-middleware</code>，将前后端进行合并。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-keyword">const</span> middle = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-dev-middleware&#x27;</span>)<br><span class="hljs-keyword">const</span> compile = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.js&#x27;</span>)<br><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">middle</span>(compile))<br><br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;请求user成功&#x27;</span><br>  &#125;)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;3000&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at port 3000...&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>jsonp</li>
</ol>
<p>比较老、兼容性好的方式。</p>
<p>利用标签没有跨域限制的漏洞，在 script 标签上我们可以引用其他服务上的脚本。</p>
<p>最常见的场景就是 CDN.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>))<br>&#125;<br><br><span class="hljs-comment">// 动态创建 script 标签，设置好 scr 属性，主要参数是 cb=callback</span><br><br><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://127.0.0.1:3000/info/jsonp?cb=callback&#x27;</span><br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementByTagsName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script)<br></code></pre></td></tr></table></figure>

<h1 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h1><p>模式有两种：</p>
<ol>
<li>hash 模式</li>
<li>history 模式</li>
</ol>
<hr>
<ul>
<li><strong>hash 模式</strong></li>
</ul>
<p>URL 的 hash 也就是锚点（#），本质上是改变 window.location 的 href 属性。可以直接给 href 复制，但是页面不刷新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">location.<span class="hljs-property">href</span> <span class="hljs-comment">// 获取当前浏览器 url: &#x27;https://www.baidu.com/&#x27;</span><br><br>location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;/foo&#x27;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>history 模式</strong></li>
</ul>
<p>HTML5 新增。</p>
<p>它有五种模式改变 url 而不刷新页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">history.<span class="hljs-title function_">pushState</span>(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/foo&#x27;</span>)<br>history.<span class="hljs-title function_">replaceState</span>(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/foo&#x27;</span>)<br>history.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>)<br><br>history.<span class="hljs-title function_">back</span>() <span class="hljs-comment">// 等价 history.go(-1)</span><br>history.<span class="hljs-title function_">forward</span>() <span class="hljs-comment">// history.go(1)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>vue-router</li>
</ul>
<p>在 Vue 中，有两种方式可以跳转路由：</p>
<ul>
<li>申明式路由 <code>&lt;router-link to=&quot;/go&quot;&gt;跳转&lt;/router-link&gt;</code></li>
<li>编程式路由 <code>this.$router.go(&#39;/go&#39;)</code></li>
</ul>
<p><strong>实现 vue-router 路由</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1n24y1w7kP?p=25&amp;spm_id_from=pageDriver&amp;vd_source=a9f38e58a519cc0570c2dacd34ad7ebe">https://www.bilibili.com/video/BV1n24y1w7kP?p=25&amp;spm_id_from=pageDriver&amp;vd_source=a9f38e58a519cc0570c2dacd34ad7ebe</a></p>
</blockquote>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote>
<p>所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。</p>
</blockquote>
<p>特点：</p>
<ol>
<li><p>对象的状态不受外界影响（pedding, resolved, rejected）</p>
</li>
<li><p>一旦状态改变就不会再改变</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-literal">true</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-literal">false</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved）</p>
<p>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params">ms</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// setTimeout 第三个参数，是传递给第一个函数的，这里是resolve 方法</span><br>    <span class="hljs-built_in">setTimeout</span>(resolve, ms, <span class="hljs-string">&#x27;done&#x27;</span>)<br>  &#125;)<br>&#125;<br><br><span class="hljs-title function_">timeout</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>resolve函数的参数除了正常的值外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作：</p>
<p><strong>p1的状态决定了p2的状态</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;fail&#x27;</span>))<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;)<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">r</span>(p1)<br>&#125;)<br><br>p2.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;result &#x27;</span>, result)<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error &#x27;</span>, error)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上面的代码中，p1是一个Promise,3秒之后变为Rejected。p2的状态由p1决定，p2调用resolve方法，但是此时p1的状态还没有改变，因此p2的状态也不会变。等3秒过后，p1变为Rejected,p2也跟着变为Rejected。</p>
<p><strong>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>  <span class="hljs-title function_">r</span>(x + <span class="hljs-number">2</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;结果 &#x27;</span>, res)<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误 &#x27;</span>, err)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;随便打印&#x27;</span>)<br>&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;最后打印&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// =======&gt;</span><br>错误  <span class="hljs-title class_">ReferenceError</span>: x is not defined<br><br>随便打印<br><br>最后打印<br></code></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><blockquote>
<p>Promise.all方法用于将多个Promise实例包装成一个新的Promise实例。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([p1, p2, p3])<br></code></pre></td></tr></table></figure>

<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<ol>
<li><p>只有p1、p2、p3的状态都变成Fulfilled,p的状态才会变成Fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>
</li>
<li><p>只要p1、p2、p3中有一个被Rejected,p的状态就变成Rejected，此时第一个被Rejected的实例的返回值会传递给p的回调函数。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">r</span>(<span class="hljs-string">&#x27;p3 success&#x27;</span>)<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> allP = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-title function_">p3</span>()])<br><br>allP.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(r)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上面的例子，3秒后，输出 <code>[ 1, 2, &#39;p3 success&#39; ]</code></p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><blockquote>
<p>竞速</p>
<p>有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
</blockquote>
<p>超时处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<br>  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/api/user&#x27;</span>),<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Request timeout&#x27;</span>))<br>    &#125;, <span class="hljs-number">5000</span>)<br>  &#125;)<br>])<br></code></pre></td></tr></table></figure>

<p>上面的代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为Rejected，从而触发catch方法指定的回调函数。</p>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h1><p>async/await被称为Generator函数的语法糖，是因为它们之间具有一些相似的特性和作用。</p>
<p>使用Generator函数时，需要手动编写迭代器的控制逻辑，即不断调用next方法来推进函数的执行。而async函数则更加简洁，通过使用async关键字声明函数，并在函数内部使用await关键字来等待异步操作的完成。使用await关键字可以暂停函数的执行，等待Promise对象的解析，并将解析值作为结果返回。整个过程更加类似于同步代码的书写，避免了手动编写迭代器的繁琐操作。</p>
<p>从语法角度来看，async/await确实简化了异步编程的过程，使得代码更加易读和易于维护。它们隐藏了Generator函数的复杂性，并提供了更直观的方式来处理异步操作。因此，我们可以说async/await是Generator函数的一种更高级的语法糖形式。</p>
<p>async/await的内部原理是基于Generator函数来实现的。在JavaScript引擎内部，async函数会被转化为一个状态机，而await表达式会被转化为适当的yield表达式。</p>
<p>当遇到一个async函数时，JavaScript引擎会将其转化为一个返回Promise的普通函数。在函数内部，通过Generator函数的方式来实现异步操作的控制流。</p>
<p>我们来看一段 <code>async/await</code> 转为为 <code>ES5</code> 的代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span> () &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-title function_">async1</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><br><br><span class="hljs-comment">// ===================== 转为 es5 的代码后 =====================</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">async2</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-title function_">async1</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure>

<p>async函数返回一个Promise对象，可以使用then方法添加回调函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-comment">// 相当于 return Promise.resolve(&#x27;name&#x27;)</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sayName</span>()) <span class="hljs-comment">// Promise &#123; &#x27;name&#x27; &#125;</span><br><br><span class="hljs-title function_">sayName</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)) <span class="hljs-comment">// name</span><br><br></code></pre></td></tr></table></figure>

<p>当函数执行时，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>我们来实现一个 sleep 睡眠函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 睡眠函数</span><br><span class="hljs-keyword">const</span> sleep = <span class="hljs-keyword">function</span>(<span class="hljs-params">ms</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">r</span>()<br>    &#125;, ms);<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>)<br><br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;name&#x27;</span><br>&#125;<br><br><span class="hljs-title function_">sayName</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br></code></pre></td></tr></table></figure>

<p>当我们调用 sayName 方法时，会立即打印出 1, 3秒过后，打印 2 和 ’name‘</p>
<p><strong>注意</strong></p>
<p>await命令后面的Promise对象，运行结果可能是Rejected，所以最好把 await 命令放在try…catch代码块中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> sleep = <span class="hljs-keyword">function</span>(<span class="hljs-params">ms</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这里报错，会被外面的 try-catch 接收到</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xxxxx + <span class="hljs-number">3</span>)<br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// setTimeout 内部报错，不会被外部的 try catch 捕获到</span><br>      <span class="hljs-title function_">r</span>()<br>    &#125;, ms)<br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>)<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27; - - - &#x27;</span>, error)<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">sayName</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))<br></code></pre></td></tr></table></figure>

<h1 id="迭代器-Symbol-iterator"><a href="#迭代器-Symbol-iterator" class="headerlink" title="迭代器 Symbol.iterator"></a>迭代器 Symbol.iterator</h1><p>不改变等式代码，如何让下面这个等式成立？</p>
<p><code>let [a, b, c] = &#123; a: 1, b: 2 &#125;</code></p>
<p>对象是不具备 <code>Symbol.iterator</code> 迭代器工厂函数的，我们可以手动创建一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>)[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br>&#125;<br><br><span class="hljs-keyword">let</span> [a, b, c] = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;result &#x27;</span>, a, b, c)<br></code></pre></td></tr></table></figure>

<p>解构操作，调用迭代器方法。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JavaScript/">JavaScript</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/module-bundler.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">模块化打包器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/web-components.html">
                        <span class="hidden-mobile">Web Components</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://yoursite.com/post/%E9%87%8D%E6%B8%A9JavaScript.html';
          this.page.identifier = '/post/%E9%87%8D%E6%B8%A9JavaScript.html';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'helloalexcc' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hello-alex-cheng.github.io/" target="_blank" rel="nofollow noopener"><span>I</span></a> <i class="iconfont icon-love"></i> <a href="https://hello-alex-cheng.github.io/" target="_blank" rel="nofollow noopener"><span>YOU</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
