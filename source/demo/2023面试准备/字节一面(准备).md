# 0.1 + 0.2不等于0.3？

> https://juejin.cn/post/6844903680362151950

JavaScript使用Number类型表示数字（整数和浮点数），遵循 `IEEE754(二进制浮点数算术)` 标准 通过64位来表示一个数字

本质是：二进制模拟十进制进行计算时 的精度问题

IEEE754 的存储位有限

在二进制的处理过程中有两次精度丢失问题，一次是 存储，一次是相加，最终导致 `0.1 + 0.2 = 0.30000000000000004`

## 十进制小数如何转二进制？

十进制小数转二进制，小数部分，乘 2 取整数，若乘之后的小数部分不为 0，继续乘以 2 直到小数部分为 0 ，将取出的整数正向排序。

```js
0.1 * 2 = 0.2 --------------- 取整数 0，小数 0.2
0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4
0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8
0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6
0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2
0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4
0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8
0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6
0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2
...
```
最终 0.1 的二进制表示为 0.00110011... 后面将会 0011 无限循环，因此二进制无法精确的保存类似 0.1 这样的小数。那这样无限循环也不是办法，又该保存多少位呢？

## 遵循 IEEE 754 标准。

IEEE 754 常用的两种浮点数值的表示方式为：单精确度（32位）、双精确度（64位）。例如， C 语言中的 float 通常是指 IEEE 单精确度，而 double 是指双精确度。

# Number() 的存储空间是多大？

Math.pow(2, 53) ，53 为有效数字，会发生截断，等于 JS 能支持的最大数字。

```js
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
```

# JS 数据类型

基本类型（七中）：number, string, undefined, null, boolean, Symbol, bigint

引用类型：Object，对象子类型（array, function）

# 事件流

事件流是网页元素接收事件的顺序，"DOM2级事件"规定的事件流包括三个阶段：`事件捕获阶段、处于目标阶段、事件冒泡阶段`。

```html
<body>
  <p>
    父元素<span>子元素</span>
  </p>

  <script>

    const p = document.querySelector('p')
    const s = document.querySelector('span')

    s.addEventListener('click', () => {
      console.log('子   捕获')
    }, true)
    s.addEventListener('click', () => {
      console.log('子   冒泡')
    }, false)

    p.addEventListener('click', () => {
      console.log('父组件捕获')
    }, true)
      p.addEventListener('click', () => {
      console.log('父组件冒泡')
    }, false)
    
  </script>
</body>
```

同时存在捕获和冒泡事件时，点击 span 元素，会打印如下，遵循事件流的执行顺序。

```js
父组件捕获
子   捕获
子   冒泡
父组件冒泡
```

# 什么是作用域

作用域（Scope）是指在程序中定义`变量的可访问范围`。它规定了在哪些地方以及如何能够访问变量、函数和对象。


es5：全局作用域和函数作用域，es6 有了块级作用域

# 闭包

闭包是一种特殊的对象，它由两部分组成：执行上下文（代号 A），以及在该执行上下文中创建的函数 （代号 B），当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生。

闭包是指有权访问另外一个函数作用域中的变量的函数

## 应用场景

- 封装私有变量

- 延迟执行：使用闭包可以实现延迟执行函数，即将一个函数作为返回值返回，并在后续的某个时刻执行该函数

- 模块化开发：通过闭包可以创建模块化的代码结构，将相关的函数和数据封装在一个闭包内部，提供对外暴露的接口，隐藏实现的细节。

- 循环中的问题：在使用循环时，闭包可以解决由于 JavaScript 作用域机制导致的变量共享问题。

- 防抖和节流：通过闭包可以实现防抖（debounce）和节流（throttle）等常见的函数优化技术，用于控制函数的触发频率。

- 实现高阶函数：闭包可以用于实现高阶函数，即函数作为参数或返回值的函数。通过闭包，可以捕获并记住外部函数的上下文和状态。

# 作用域链

当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止

# this 的四条规则

- 默认绑定

没有其他修饰（bind、apply、call)，在非严格模式下定义指向全局对象，在严格模式下定义指向 undefined

- 隐式绑定

调用位置是否有上下文对象，或者是否被某个对象拥有或者包含，那么隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。

```js
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
}

obj.foo(); // 2
```

- 显示绑定：通过在函数上运行 call 和 apply ，来显示的绑定 this

- new 绑定

# 手写 call、apply、bind

call

```js
Function.prototype.myCall = function(context, ...args) {
  // context 就是 call 第一个参数，上下文环境
  context = typeof context === 'object' ? context || window : {};

  const s = Symbol('fn')
  context[s] = this // 将方法 赋值给 context 对象,

  const result = context[s](...args) // 在目标对象上(context)调用方法，方法内部的 this 就指向 context 了

  delete context[s] // 记得删除context 上定义的方法
  
  return result
}
```

apply 基本和 call 一样，只是参数不同，apply 接受一个数组作为参数。

bind 基本上和 call、apply 也很相似，只不过返回了一个函数，执行时机灵活多变。

```js
Function.prototype.myBind = function(context, ...args) {
  context = context || window
  const s = Symbol('fn')

  context[s] = this

  return function(..._args) {
    args = args.concat(_args)
    const r = context[s](...args)

    delete context[s]

    return r
  }
}
```

# 实现一个 pipe 函数

```js
const square = v => v * v
const double = v => v * 2
const addOne = v => v + 1

const res = pipe(square, double, addOne)

console.log(res(3)) // 19; addOne(double(square(3)))
```

pipe是可以接收任意个数的函数，并且返回的是一个新的函数

```js
function pipe(...fns) {
  
  // value 就是传入进来的数字
  return function(value) {

    return fns.reduce((pre, cur) => {

      return cur(pre)
    }, value)
  }
}
```

由于 value 作为 reduce 的初始值，所以，第一次循环的结果是 cur(value)，也就是 square(3)

第二次循环时，square(3) 就是 pre，cur(pre) 就是 `double(square(3))`，以此类推...

# 如何判断一个对象是不是空对象

```js
Object.keys(obj).length === 0
```

# 扁平化一个数组

```js
const arr = [1, [2, 3, [4, [ 5 ]]]]

function flatten(arr) {
  const result = []

  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result.push(...flatten(arr[i]))
    } else {
      result.push(arr[i])
    }
  }

  return result
}

console.log(flatten(arr))
```

# 排序-冒泡 O(n^2)

```js
const arr = [3, 1, 2, 6, 1, 99, 0, -1, 5]

// 冒泡
function bubbleSort(arr) {
  let length = arr.length

  for (let i = 0; i < length; i++) {
    for (let j = 1; j < length - i; j++) {
      if (arr[j] < arr[j - 1]) {
        // const temp = arr[j]
        // arr[j] = arr[j - 1]
        // arr[j - 1] = temp

        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]
      }
    }
  }

  return arr
}

console.log(bubbleSort(arr))
```

# 排序-选择排序 O(n^2)

假设数组第一个元素就是最小的值，双循环遍历数组，找到可能存在最小的值，和假定的最小值交换位置

第二层循环 j = i，表示已经排序了的，不需要再遍历查找了

```js
function selectSort(arr) {
  let minIndex
  for (let i = 0; i < arr.length; i++) {
    // 假设一个最小的值
    minIndex = i

    // 让 j = i，表示前面已经排序了的，就不需要再排了
    for (let j = i; j < arr.length; j ++) {
      // 一轮下来，肯定能找到一个最小值 index
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }

    // 如果 minIndex !== i，表示存在比arr[minIndex]还小的值 arr[i]，和 i 进行交换
    if (minIndex !== i) {
      [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]
    }
  }

  return arr
}
```

# 排序-插入排序

arr = [3, 2, 1, 6, 1, 99, 0, -1, 5]

1. 默认第一项是排序了的，所以遍历时从数组下标为 1 的位置开始

2. 用 for 循环将当前遍历的项存储起来，current，并记录当前项的下标currentIndex

3. 通过 while 循环，current 前面的项 和 current 比较

```js
function insertSort(arr) {
  let current, currentIndex // 当前项, 当前项下标

  for (let i = 1; i < arr.length; i++) {

    current = arr[i] 
    currentIndex = i

    // 让当前项的前面的每一项和当前项 current 比较，
    while (currentIndex > 0 && arr[currentIndex - 1] > current) {
      arr[currentIndex] = arr[currentIndex - 1]
      currentIndex--
    }

    // currentIndex = 0
    arr[currentIndex] = current
  }

  return arr
}
```

`第一轮`：

arr = [3, 2, 1, 6, 1, 99, 0, -1, 5]

current = 2, currentIndex = 1

current 前一项`arr[currentIndex - 1] = 3`比 current = 2 大，那就让当前项 arr[currentIndex] 等于前一项，相当于大数字往后挪了一位，[3, 3, 1, 6 ...]

然后 currentIndex-- = 0，currentIndex > 0 不成立，结束 while，此时前两项是 [3, 3]

最后，currentIndex = 0，需要让当前项（小值）插入到正确✅的位置

arr[currentIndex] = current，前两项就排好序了 [2,3]


`第二轮`

arr = [2, 3, 1, 6, 1, 99, 0, -1, 5]

current = 1, currentIndex = 2

current 的前一项 `arr[currentIndex - 1] = 3` 比 current = 1 大，需要将大的往后挪一位，arr[currentIndex: 2] = arr[currentIndex - 1]，[2, 3, 1] => [2, 3, 3]

然后 currentIndex-- = 1，还要判断前面的项，是不是有比 current 大的数值，arr[currentIndex-1] > current （2 > 1）成立，所以将大的数值往后挪一位 [2, 3, 3] => [2, 2, 3]

currentIndex-- = 0，此时 currentIndex 等于 0，不符合 while 循环的条件了，退出

最后，我们需要将小的值插入到正确✅的位置：arr[currentIndex: 0] = current(1)  => [1, 2, 3 ...]

...

## 时间复杂度

最好的情况是，arr 本来就是有序的，所以每一次循环，都只需要比较一次，并且不需要交换位置，时间复杂度是 O(n - 1) ====> 去掉常量就是 O(n)

最坏的情况是，arr 是逆序的，每一次比较，都需要将前面的每一项都挪一下位置，并且将当前项插入到数组的头部，此时复杂度是 `O(n^2)`

空间复杂度是 `O(1)`

# meta 标签：自动刷新/跳转

假设要实现一个类似 PPT 自动播放的效果，你很可能会想到使用 JavaScript 定时器控制页面跳转来实现。但其实有更加简洁的实现方法，比如通过 meta 标签来实现：

```html
<meta http-equiv="Refresh" content="5; URL=page2.html"> 
```
上面的代码会在 5s 之后自动跳转到同域下的 page2.html 页面。我们要实现 PPT 自动播放的功能，只需要在每个页面的 meta 标签内设置好下一个页面的地址即可。

另一种场景，比如每隔一分钟就需要`刷新页面`的大屏幕监控，也可以通过 meta 标签来实现，只需去掉后面的 URL 即可：

<meta http-equiv="Refresh" content="60">
