# 0.1 + 0.2不等于0.3？

> https://juejin.cn/post/6844903680362151950

JavaScript使用Number类型表示数字（整数和浮点数），遵循 `IEEE754(二进制浮点数算术)` 标准，通过64位来表示一个数字

本质是：二进制模拟十进制进行计算时 的精度问题

IEEE754 的存储位有限

在二进制的处理过程中有两次精度丢失问题，一次是 存储，一次是相加，最终导致 `0.1 + 0.2 = 0.30000000000000004`

## 十进制整数转二进制

整数除2，取余数，没有余数取0

## 十进制小数如何转二进制？

十进制小数转二进制，小数部分 `乘 2 取整数部分`，若乘之后的小数部分不为 0，继续乘以 2 直到小数部分为 0 ，将取出的整数正向排序。

`0.1` 转二进制：

```js
0.1 * 2 = 0.2 --------------- 取整数 0，小数 0.2
0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4
0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8
0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6
0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2
0.2 * 2 = 0.4 --------------- 取整数 0，小数 0.4
0.4 * 2 = 0.8 --------------- 取整数 0，小数 0.8
0.8 * 2 = 1.6 --------------- 取整数 1，小数 0.6
0.6 * 2 = 1.2 --------------- 取整数 1，小数 0.2
...
```
最终 0.1 的二进制表示为 0.00110011... 后面将会 `0011 无限循环`，因此二进制无法精确的保存类似 0.1 这样的小数。`任何使用二进制浮点数的编程语言都有这个问题`

那这样无限循环也不是办法，又该保存多少位呢？

## 遵循 IEEE 754 标准。

IEEE 754 常用的两种浮点数值的表示方式为：单精确度（32位）、双精确度（64位）。例如， C 语言中的 float 通常是指 IEEE 单精确度，而 double 是指双精确度。

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMjY1MDUyOC1lMjMwMjk5NjhlYjU3MmQzLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwfGltYWdlVmlldzIvMi93Lzc4Ni9mb3JtYXQvd2VicA?x-oss-process=image/format,png" />

- 符号位（位数：1）决定了一个数的正负

- 指数位（位数：11）决定了数值的大小

- 小数位（位数：52）决定了数值的精度

JS 中的数字类型只有 Number 一种，而 Number 类型采用的是 IEEE 754 标准中的 `双精度浮点数（64位）` 来表示一个数字，不区分整数和浮点数。

所以，JS 中提供的有效位是 `64 - 11` 为 `53` 位。

将 `0.1` 或 `0.2` 转为二进制数时，会出现无限循环，而二进制存储结构中的小数部分，最多只能表示 53 位。为了能表示 0.1 这类小数，只能进行舍入（类似四舍五入这种），但是二进制只有 0 和 1，于是就变成了 `0舍1入`。

```js
// 0.1

0.0001100110011001100110011001100110011001100110011001101 // 舍0，1入，最后两位变成了 01
```

所以，在 0.1 和 0.2 进行二进制转换时，丢失了一次精度。

在二进制求和时，又丢失了一次精度，最终导致求和不准确 `0.1 + 0.2 !== 0.3`

## JS中最大安全整数

`IEEE754规定位数第一位隐含为1，不写。`

比如我们可以通过 `Math.pow(2, 53) - 1` 拿到`最大`的安全整数，它的值和 `Number.Number.MAX_SAFE_INTEGER` 一样

```js
Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1

Number.MIN_SAFE_INTEGER // 最小
```

## JS 中最大的数是什么？

`Infinity`

```js
typeof Infinity ===> 'number'
```

## 解决

1. 可以先将其转化为整数，再除以转整数时的倍数

```js
const res = (10*0.1 + 10*0.2) / 10 // 0.3
```

2. 使用 `toFixed`

```js
(0.1+0.2).toFixed(1) ===> '0.3'
```

3. 使用 `Number.EPSILON` 最小值比较大小

```js
const equal = Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON // true
```

4. 使用计算库来解决

`math.js、decimal.js`

# JS 数据类型

基本类型（七中）：number, string, undefined, null, boolean, Symbol, bigint

引用类型：Object，对象子类型（array, function）

# 事件流

事件流是网页元素接收事件的顺序，"DOM2级事件"规定的事件流包括三个阶段：`事件捕获阶段、处于目标阶段、事件冒泡阶段`。

```html
<body>
  <p>
    父元素<span>子元素</span>
  </p>

  <script>

    const p = document.querySelector('p')
    const s = document.querySelector('span')

    s.addEventListener('click', () => {
      console.log('子   捕获')
    }, true)
    s.addEventListener('click', () => {
      console.log('子   冒泡')
    }, false)

    p.addEventListener('click', () => {
      console.log('父组件捕获')
    }, true)
      p.addEventListener('click', () => {
      console.log('父组件冒泡')
    }, false)
    
  </script>
</body>
```

同时存在捕获和冒泡事件时，点击 span 元素，会打印如下，遵循事件流的执行顺序。

```js
父组件捕获
子   捕获
子   冒泡
父组件冒泡
```

# 什么是作用域

作用域（Scope）是指在程序中定义`变量的可访问范围`。它规定了在哪些地方以及如何能够访问变量、函数和对象。


es5：全局作用域和函数作用域，es6 有了块级作用域

# 闭包

闭包是一种特殊的对象，它由两部分组成：执行上下文（代号 A），以及在该执行上下文中创建的函数 （代号 B），当 B 执行时，如果访问了 A 中变量对象的值，那么闭包就会产生。

闭包是指有权访问另外一个函数作用域中的变量的函数

## 应用场景

- 封装私有变量

- 延迟执行：使用闭包可以实现延迟执行函数，即将一个函数作为返回值返回，并在后续的某个时刻执行该函数

- 模块化开发：通过闭包可以创建模块化的代码结构，将相关的函数和数据封装在一个闭包内部，提供对外暴露的接口，隐藏实现的细节。

- 循环中的问题：在使用循环时，闭包可以解决由于 JavaScript 作用域机制导致的变量共享问题。

- 防抖和节流：通过闭包可以实现防抖（debounce）和节流（throttle）等常见的函数优化技术，用于控制函数的触发频率。

- 实现高阶函数：闭包可以用于实现高阶函数，即函数作为参数或返回值的函数。通过闭包，可以捕获并记住外部函数的上下文和状态。

# 作用域链

当访问一个变量时，编译器在执行这段代码时，会首先从当前的作用域中查找是否有这个标识符，如果没有找到，就会去父作用域查找，如果父作用域还没找到继续向上查找，直到全局作用域为止

# this 的四条规则

- 默认绑定

没有其他修饰（bind、apply、call)，在非严格模式下定义指向全局对象，在严格模式下定义指向 undefined

- 隐式绑定

调用位置是否有上下文对象，或者是否被某个对象拥有或者包含，那么隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。

```js
function foo() {
  console.log(this.a);
}

var obj = {
  a: 2,
  foo: foo,
}

obj.foo(); // 2
```

- 显示绑定：通过在函数上运行 call 和 apply ，来显示的绑定 this

- new 绑定

# 手写 call、apply、bind

call

```js
Function.prototype.myCall = function(context, ...args) {
  // context 就是 call 第一个参数，上下文环境
  context = typeof context === 'object' ? context || window : {};

  const s = Symbol('fn')
  context[s] = this // 将方法 赋值给 context 对象,

  const result = context[s](...args) // 在目标对象上(context)调用方法，方法内部的 this 就指向 context 了

  delete context[s] // 记得删除context 上定义的方法
  
  return result
}
```

apply 基本和 call 一样，只是参数不同，apply 接受一个数组作为参数。

bind 基本上和 call、apply 也很相似，只不过返回了一个函数，执行时机灵活多变。

```js
Function.prototype.myBind = function(context, ...args) {
  context = context || window
  const s = Symbol('fn')

  context[s] = this

  return function(..._args) {
    args = args.concat(_args)
    const r = context[s](...args)

    delete context[s]

    return r
  }
}
```

# 实现一个 pipe 函数

```js
const square = v => v * v
const double = v => v * 2
const addOne = v => v + 1

const res = pipe(square, double, addOne)

console.log(res(3)) // 19; addOne(double(square(3)))
```

pipe是可以接收任意个数的函数，并且返回的是一个新的函数

```js
function pipe(...fns) {
  
  // value 就是传入进来的数字
  return function(value) {

    return fns.reduce((pre, cur) => {

      return cur(pre)
    }, value)
  }
}
```

由于 value 作为 reduce 的初始值，所以，第一次循环的结果是 cur(value)，也就是 square(3)

第二次循环时，square(3) 就是 pre，cur(pre) 就是 `double(square(3))`，以此类推...

# 如何判断一个对象是不是空对象

```js
Object.keys(obj).length === 0

```
JSON.stringify 不能用来判断是不是空对象，因为如果属性值是 function 或者 undefined，序列化出来之后会丢失这两个属性

# 扁平化一个数组

```js
const arr = [1, [2, 3, [4, [ 5 ]]]]

function flatten(arr) {
  const result = []

  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result.push(...flatten(arr[i]))
    } else {
      result.push(arr[i])
    }
  }

  return result
}

console.log(flatten(arr))
```

# 排序-冒泡 O(n^2)

```js
const arr = [3, 1, 2, 6, 1, 99, 0, -1, 5]

// 冒泡
function bubbleSort(arr) {
  let length = arr.length

  for (let i = 0; i < length; i++) {
    for (let j = 1; j < length - i; j++) {
      if (arr[j] < arr[j - 1]) {
        // const temp = arr[j]
        // arr[j] = arr[j - 1]
        // arr[j - 1] = temp

        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]]
      }
    }
  }

  return arr
}

console.log(bubbleSort(arr))
```

# 排序-选择排序 O(n^2)

假设数组第一个元素就是最小的值，双循环遍历数组，找到可能存在最小的值，和假定的最小值交换位置

第二层循环 j = i，表示已经排序了的，不需要再遍历查找了

```js
function selectSort(arr) {
  let minIndex
  for (let i = 0; i < arr.length; i++) {
    // 假设一个最小的值
    minIndex = i

    // 让 j = i，表示前面已经排序了的，就不需要再排了
    for (let j = i; j < arr.length; j ++) {
      // 一轮下来，肯定能找到一个最小值 index
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }

    // 如果 minIndex !== i，表示存在比arr[minIndex]还小的值 arr[i]，和 i 进行交换
    if (minIndex !== i) {
      [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]
    }
  }

  return arr
}
```

# 排序-插入排序

arr = [3, 2, 1, 6, 1, 99, 0, -1, 5]

1. 默认第一项是排序了的，所以遍历时从数组下标为 1 的位置开始

2. 用 for 循环将当前遍历的项存储起来，current，并记录当前项的下标currentIndex

3. 通过 while 循环，current 前面的项 和 current 比较

```js
function insertSort(arr) {
  let current, currentIndex // 当前项, 当前项下标

  for (let i = 1; i < arr.length; i++) {

    current = arr[i] 
    currentIndex = i

    // 让当前项的前面的每一项和当前项 current 比较，
    while (currentIndex > 0 && arr[currentIndex - 1] > current) {
      arr[currentIndex] = arr[currentIndex - 1]
      currentIndex--
    }

    // currentIndex = 0
    arr[currentIndex] = current
  }

  return arr
}
```

`第一轮`：

arr = [3, 2, 1, 6, 1, 99, 0, -1, 5]

current = 2, currentIndex = 1

current 前一项`arr[currentIndex - 1] = 3`比 current = 2 大，那就让当前项 arr[currentIndex] 等于前一项，相当于大数字往后挪了一位，[3, 3, 1, 6 ...]

然后 currentIndex-- = 0，currentIndex > 0 不成立，结束 while，此时前两项是 [3, 3]

最后，currentIndex = 0，需要让当前项（小值）插入到正确✅的位置

arr[currentIndex] = current，前两项就排好序了 [2,3]


`第二轮`

arr = [2, 3, 1, 6, 1, 99, 0, -1, 5]

current = 1, currentIndex = 2

current 的前一项 `arr[currentIndex - 1] = 3` 比 current = 1 大，需要将大的往后挪一位，arr[currentIndex: 2] = arr[currentIndex - 1]，[2, 3, 1] => [2, 3, 3]

然后 currentIndex-- = 1，还要判断前面的项，是不是有比 current 大的数值，arr[currentIndex-1] > current （2 > 1）成立，所以将大的数值往后挪一位 [2, 3, 3] => [2, 2, 3]

currentIndex-- = 0，此时 currentIndex 等于 0，不符合 while 循环的条件了，退出

最后，我们需要将小的值插入到正确✅的位置：arr[currentIndex: 0] = current(1)  => [1, 2, 3 ...]

...

## 时间复杂度

最好的情况是，arr 本来就是有序的，所以每一次循环，都只需要比较一次，并且不需要交换位置，时间复杂度是 O(n - 1) ====> 去掉常量就是 O(n)

最坏的情况是，arr 是逆序的，每一次比较，都需要将前面的每一项都挪一下位置，并且将当前项插入到数组的头部，此时复杂度是 `O(n^2)`

空间复杂度是 `O(1)`

# meta 标签：自动刷新/跳转

假设要实现一个类似 PPT 自动播放的效果，你很可能会想到使用 JavaScript 定时器控制页面跳转来实现。但其实有更加简洁的实现方法，比如通过 meta 标签来实现：

```html
<meta http-equiv="Refresh" content="5; URL=page2.html"> 
```
上面的代码会在 5s 之后自动跳转到同域下的 page2.html 页面。我们要实现 PPT 自动播放的功能，只需要在每个页面的 meta 标签内设置好下一个页面的地址即可。

另一种场景，比如每隔一分钟就需要`刷新页面`的大屏幕监控，也可以通过 meta 标签来实现，只需去掉后面的 URL 即可：

<meta http-equiv="Refresh" content="60">

# 跟跨域相关的几个请求头含义是什么？

在跨域请求中，以下是几个常见的与跨域相关的请求头及其含义：

1. **Origin**: 该请求头指示了请求的来源，包含了协议、域名和端口号。它通常由浏览器自动添加，并用于表示当前页面的域和协议。在跨域请求中，服务器可以通过检查该请求头来确定是否允许跨域访问。

2. **Access-Control-Request-Method**: 当浏览器发起跨域的 HTTP 预检请求（OPTIONS 请求）时，该头部用于指示实际请求所使用的方法（如 GET、POST、PUT 等）。服务器可以根据该头部来判断是否允许实际请求的方法。

3. **Access-Control-Request-Headers**: 当浏览器发起跨域的 HTTP 预检请求时，该头部用于指示实际请求所携带的自定义请求头。服务器可以根据该头部来判断是否允许实际请求携带这些自定义请求头。

4. **Access-Control-Allow-Origin**: 该响应头用于指示服务器是否允许来自特定源的跨域请求。当服务器接收到跨域请求时，可以通过设置该头部来告知浏览器是否允许访问。可以设置为具体的域名或 `*`（表示允许所有域名），以控制跨域访问的权限。

5. **Access-Control-Allow-Methods**: 该响应头用于指示服务器允许的跨域请求方法。服务器可以通过设置该头部来告知浏览器所允许的请求方法，以控制跨域请求的权限。

6. **Access-Control-Allow-Headers**: 该响应头用于指示服务器允许的跨域请求头。服务器可以通过设置该头部来告知浏览器所允许的请求头，以控制跨域请求携带自定义头部的权限。

这些请求头和响应头是跨域请求中常见的一些标准头部，用于在浏览器和服务器之间进行跨域访问的协商和控制。它们的作用是确保跨域请求的安全性和权限控制。

# ES6 的 map 和 Object 有什么区别？

ES6中的Map和Object都是用于存储和操作数据的集合，但它们有以下几个主要区别：

1. 键的类型：Object的键只能是`字符串或符号`，而`Map的键可以是任意数据类型，包括原始类型和引用类型`。

2. 键值对的顺序：Map会按照插入顺序维护键值对的顺序，而Object不会保留插入顺序，它是基于哈希表实现的。

3. 大小获取：Map有size属性可以获取键值对的数量，而Object没有内置的属性或方法可以直接获取键值对的数量，需要手动计算。

4. 迭代遍历：Map提供了迭代器（Iterator）可以用于遍历键值对，包括for...of循环、forEach方法等，而Object需要使用Object.keys()、Object.values()或者for...in循环来遍历属性和值。

5. 作为键的唯一性：Map中可以使用引用类型作为键，并且它们的引用不同也会被视为不同的键，而Object中使用的键会被转换为字符串，如果键的类型不是字符串或符号，会自动转换为字符串形式。

6. 内存占用：由于Map的实现方式不同于Object，它在处理大量键值对时通常比Object占用更多的内存。

基于上述区别，选择使用Map还是Object取决于具体的需求。如果需要保持插入顺序、需要使用非字符串键或需要更灵活的键值对操作，可以选择使用Map。如果只需要简单的键值对映射、不关心顺序，或者键是字符串类型，可以使用Object。

# 一个盒子（div）从中间开始，碰到最左边的边界后往右移动，碰到最右边的边界后往左移动，这个怎么实现呢？

`<div class="box"></div>`

css 实现方式

```css
.box {
  width: 100px;
  height: 100px;
  background-color: red;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  animation: moveBox 1s infinite linear;
}

@keyframes moveBox {
  0% {
    transform: translateX(-50%);
  }
  50% {
    transform: translateX(calc(100% - 50px));
  }
  100% {
    transform: translateX(-50%);
  }
}
```

js 实现方式

```js
const box = document.querySelector('.box');
const viewportWidth = window.innerWidth; // 拿到窗口的宽度
const boxWidth = box.offsetWidth; // 盒子宽度

let direction = 10; // 移动方向，1表示向右，-1表示向左

function moveBox() {
  const boxLeft = box.offsetLeft; // 拿到盒子与左边界的距离
  
  if (boxLeft <= 0) {
    // 碰到最左边的边界，改变移动方向为向右
    direction = 10;
  } else if (boxLeft + boxWidth >= viewportWidth) {
    // 碰到最右边的边界，改变移动方向为向左
    direction = -10;
  }
  
  // 当 direction 数值为 1，left 会不停的 +1，向右移动
  box.style.left = `${boxLeft + direction}px`;
  
  requestAnimationFrame(moveBox);
}

moveBox();
```

# requestAnimationFrame 和 setInterval 有什么区别?

window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在`下次重绘之前`调用指定的回调函数更新动画。

该方法需要传入一个回调函数作为参数，该回调函数会`在浏览器下一次重绘之前执行`。

回调函数执行次数通常是每秒 60 次，但在大多数遵循 W3C 建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。


- 返回值

一个 long 整数，请求 ID，是回调列表中唯一的标识。是个非零值，没有别的意义。你可以传这个值给 `window.cancelAnimationFrame()` 以取消回调函数请求。

- 和 setInterval 区别

1. 调用频率：`requestAnimationFrame`会根据浏览器的刷新频率进行调用，通常为每秒60次（60fps）。而`setInterval`则是按照设定的时间间隔进行调用。

2. 动画性能：`requestAnimationFrame`在动画效果中具有更好的性能表现。它能够在浏览器的重绘之前执行回调函数，保证在合适的时机更新动画，避免造成过度绘制或不连续的动画效果。而`setInterval`则可能在浏览器重绘之间执行回调，导致动画不稳定或出现抖动。

3. 暂停和恢复：使用`requestAnimationFrame`可以方便地暂停和恢复动画。通过控制回调函数的执行与否，可以在需要时停止动画，在恢复时重新启动动画。而使用`setInterval`时，如果需要暂停动画，需要清除定时器，并在恢复时重新设置定时器。

4. 节省资源：由于`requestAnimationFrame`的调用频率与浏览器的刷新频率相匹配，因此它比`setInterval`更有效地利用了系统资源。它能够避免不必要的计算和绘制，提高页面性能和电池寿命。

如果要实现动画效果，尤其是在性能要求较高的情况下，推荐使用`requestAnimationFrame`。而`setInterval`适用于一些简单的定时任务，不涉及精确的动画效果。

# Promise

## Promise.all

Promise.all() 方法接收一个 promise 的 iterable 类型（注：Array，Map，Set 都属于 ES6 的 iterable 类型）的输入，并且只返回一个Promise实例，那个输入的所有 promise 的 resolve 回调的结果是一个数组。

这个Promise的 `resolve 回调执行是在所有输入的 promise 的 resolve 回调都结束`，或者输入的 iterable 里没有 promise 了的时候。

它的 reject 回调执行时，只要任何一个输入的 promise 的 reject 回调执行或者输入不合法的 promise 就会立即抛出错误，并且 reject 的是第一个抛出的错误信息。

`失败/拒绝（Rejection）： 如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其他 promise 是否完成。`

## Promise.allSettled

Promise.allSettled() 方法以 promise 组成的可迭代对象作为输入，并且返回一个 Promise 实例。当输入的所有 promise 都已敲定时（包括传递空的可迭代类型），返回的 promise 将兑现，并带有描述每个 promsie 结果的对象数组

```js
const promise1 = Promise.resolve(333);
const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'foo'));
const promises = [promise1, promise2, 3];

Promise.allSettled(promises).then(res => {
  res.forEach(r => console.log(r))
})

// =====> 输出

> Object { status: "fulfilled", value: 333 }
> Object { status: "rejected", reason: "foo" }
> Object { status: "fulfilled", value: 3 }
```

跟 all 的区别就是，即使有 promise reject，也会返回所有的 promise 集合。

## Promise.race()

Promise.race(iterable) 方法返回一个 promise，`一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。`

```js
var p1 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 500, "one");
});
var p2 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, "two");
});

Promise.race([p1, p2]).then(function(value) {
  console.log(value); // "two"
  // 两个都完成，但 p2 更快
});

var p3 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, "three");
});
var p4 = new Promise(function(resolve, reject) {
    setTimeout(reject, 500, "four");
});

Promise.race([p3, p4]).then(function(value) {
  console.log(value); // "three"
  // p3 更快，所以它完成了
}, function(reason) {
  // 未被调用
});

var p5 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 500, "five");
});
var p6 = new Promise(function(resolve, reject) {
    setTimeout(reject, 100, "six");
});

Promise.race([p5, p6]).then(function(value) {
  // 未被调用
}, function(reason) {
  console.log(reason); // "six"
  // p6 更快，所以它失败了
});
```

# 如何实现一个最多能并发执行 n 个 promise 的队列？

```js
class PromiseSchedule {

  constructor(max) {
    this.list = []
    this.max = max // 并发数
    this.workingNum = 0 // 当前正在执行的数量
  }

  add(cb) {
    this.list.push(cb)
  }

  start() {
    for (let i = 0; i < this.max; i++) {
      this.doNext()
    }
  }

  doNext() {
    if (this.list.length > 0 && this.workingNum < this.max) {
      this.workingNum++
      // 取出来执行
      this.list.shift()().then(() => {
        this.workingNum--
        this.doNext()
      })
    }
  }
}

const timeout = (time, value) => new Promise(resolve => setTimeout(resolve, time, value))


const scheduler = new PromiseSchedule(2)

const addTask = (time, value) => {
  scheduler.add(() => timeout(time, value).then(res => {
    console.log('打印: ', res)
  }))
}

addTask(1000, 1)
addTask(300, 2)
addTask(500, 3)
addTask(400, 4)

scheduler.start()
```

这里设置的 2 并发数量，一次只能执行两个任务。

第一次 [1(1000ms), 2(300ms)]入列，执行 300ms 输出 `2`，3(500ms) 入列

第二次 [1(1000ms), 3(500ms)]，到了800ms，执行输出 `3`，4(400ms)入列

第三次 [1(1000ms), 4(400ms)]，到了1000ms，执行输出 `1`，还剩 [4(400ms)]

最后 输出 `4`


> [介绍](https://www.bilibili.com/video/BV11f4y117qp/?buvid=ZC4FC9C58F2FDB43474B9C7695F094F5775B&is_story_h5=false&mid=aM0ztGKKOVLNW6aEI4XR9g%3D%3D&p=1&plat_id=115&share_from=ugc&share_medium=iphone&share_plat=ios&share_session_id=61DE28B0-C85F-4F2A-B026-11F2669BF824&share_source=WEIXIN&share_tag=s_i&timestamp=1685641196&unique_k=rJ6f0S1&up_id=355995969)


`使用 Promise.race 处理`

```js
function asyncFn (timeout) {
  return new Promise(r => {
    setTimeout(r, timeout, timeout);
  })
}

const tasks = [
  () => asyncFn(1000),
  () => asyncFn(4000),
  () => asyncFn(2000),
  () => asyncFn(3000),
]

async function limitRequest(tasks, limit = 2) {
  const taskPool = new Set() // 主要是为了使用集合的操作方法 delete

  for (const task of tasks) {
    const promise = task()
    taskPool.add(promise)
    promise.then(res => {
      console.log('2', res)
      taskPool.delete(promise)
    })

    if (taskPool.size >= limit) {
      console.log(1)
      await Promise.race(taskPool)
    }
  }

  // 让 limitRequest 的 .then 最后执行
  return Promise.all(taskPool)
}

limitRequest(tasks)
```

# 串行执行多个 promise

```js
const fn = (res = 0) => {
  return new Promise(r => {
    setTimeout(() => {
      console.log(1)
      r(11 + res)
    }, 1000)
  })
}


function run(list) {
  // 递归
  // const f = list.shift()
  // if (f) {
  //   f().then(res => {
  //     console.log(res)
  //     run(list)
  //   })
  // }
  
  // 循环
  // 首先创建一个初始值为 resolved 状态的 Promise 对象 promise，
  // 每次将当前 Promise 对象和下一个函数 fn 组合成一个新的 Promise 对象，
  // 并将其赋值给 promise。
  // 这样，每次循环都会生成一个新的 Promise 对象
  // 它的状态取决于上一个 Promise 对象和当前函数的执行结果。
  // 最后返回的是最后一个 Promise 对象，它的状态取决于所有函数的执行结果。
  // 这个函数的作用是实现 Promise 链式调用
  // 可以方便地处理多个异步操作的依赖关系。
  let promise = Promise.resolve(0)
  console.log(promise)
  for(const fn of list) {
    promise = promise.then(fn)
  }
  return promise
}

run([fn, fn, fn, fn])

```

# 翻转单链表

```js
// 定义两个变量

const head = NodeList

let prev = null // 用来充当末尾节点
let curr = head // 让 curr 指向 head

while(curr) {
  head = curr

  curr = curr.next // 移动 curr

  head.next = prev // 执行翻转

  prev = head
}
```

# cache设计

题目描述

设计一个对象cache，它支持下列两个基本操作：
set(id, object)，根据 id 设置对象；
get(id)：根据id得到一个对象

同时它有下面几个性质：

1. x秒自动过期，如果cache内的对象，x秒内没有被get或者set过，则会自动过期
2. 对象数限制，该cache可以设置一个n，表示cache最多能存储的对象数；
3. LRU置换，当进行set操作时，如果此时 cache内对象数已经到达了n个，则cache自动将最久未被使用过的那个对象剔除，腾出空间放置新对象；

请你设计这样一个cache ！

# 对版本号从小到大进行排序

sort 的 compareFn(a, b) 返回值表示 `排序顺序`

```js
> 0	a 在 b 后，如 [b, a]，升序排列
< 0	a 在 b 前，如 [a, b]
=== 0	保持 a 和 b 原来的顺序
```

```js
const versions = ['1.45.1', '1.5', '1.3.2', '3.3.3.3', '6'];

function compareVersions(version1, version2) {
  console.log(version1, version2)
  const nums1 = version1.split('.').map(Number);
  const nums2 = version2.split('.').map(Number);
  
  const maxLength = Math.max(nums1.length, nums2.length);
  
  for (let i = 0; i < maxLength; i++) {
    const num1 = nums1[i] || 0;
    const num2 = nums2[i] || 0;
    
    if (num1 < num2) {
      return -1;
    } else if (num1 > num2) {
      return 1;
    }
  }
  
  return 0;
}

const sortedVersions = versions.sort(compareVersions);
console.log(sortedVersions);

```

# 给定一个字符串 `str = 'a.b.c'`，获取对象的值

```js
const obj = {
  a: {
    b: {
      c: 'hello world'
    }
  }
}

const str = 'a.b.c'

function getValue(str) {
  const keys = str.split('.')
  let curr = obj

  while (keys.length) {
    curr = curr[keys.shift()]
  }

  return curr
}

console.log(getValue(str))
```

# Vue2 里面的 .sync

实现父子组件之间数据的双向绑定，与 v-model 类似，主要是为了简化操作流程

```js
<base-checkbox key="1" :msg.sync="msg" :msg1.sync="msg1" />

// base-checkbox 组件内部
<input
  :value="msg"
  @input="$emit('update:msg', $event.target.value)"
/>
```

我们修改 input 的内容，能够实时反应到父组件的数据。

```html
<body>
  <div id="editor">
    <!-- 实时更新 msg msg1 -->
    <p>{{msg}}</p>
    <p>{{msg1}}</p>
    <base-checkbox key="1" :msg.sync="msg" :msg1.sync="msg1" />
  </div>
  <script>
    Vue.component("base-checkbox", {
      props: {
        msg: String,
        msg1: String
      },
      template: `
        <div>
          <input
            :value="msg"
            @input="$emit('update:msg', $event.target.value)"
          />
          <input
            :value="msg1"
            @input="$emit('update:msg1', $event.target.value)"
          />
        </div>
      `
    });
    new Vue({
      el: "#editor",
      data: {
        msg: "msg",
        msg1: "msg1"
      }
    });
  </script>
</body>
```

# Vue中 setTimout/dom渲染/$nextTick

## 在created中更改数据
不会触发 beforeUpdate 和 updated 钩子函数

created 钩子函数执行的时候，Vue 实例已经创建，data 数据已经挂载，但是 DOM 还没有生成。beforeUpdate 和 updated 钩子函数是在数据改变导致的虚拟 DOM 重新渲染和打补丁时被调用的，也就是说这两个钩子函数是在 DOM 生成之后才会被调用的。所以在 created 钩子函数中修改数据，DOM 还没有生成，自然就不会触发 beforeUpdate 和 updated 钩子函数了。

## beforeUpdate/updated/nextTick
都是微任务

更新过程是：微任务 -> dom渲染（微任务） -> 宏任务

## dom渲染

Vue 的 DOM 更新操作是微任务。Vue 使用了一个叫做异步队列的机制，当数据发生变化时，Vue 会开启一个异步队列，并将所有的数据改变都推入这个队列。然后在下一个事件循环 "tick" 中，Vue 刷新队列并执行实际（已去重的）工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

## setTimout中修改数据并使用nextTick的问题
在调用nextTick之前，修改数据，$nextTick能够拿到最新的 dom

当nextTick在 setTimout 内部的最前面使用，再修改数据，nextTick无法拿到最新的 dom

`原因`

在不加 setTimeout 包裹的情况下，无论 nextTick 和修改数据的顺序如何，nextTick都会拿到最新的 dom 内容

那么 setTimeout 包裹后，`微任务的执行顺序`和 `代码中的顺序一致`。

看如下代码:

```html
<template>
  <div ref="box" class="box">
    {{a}},{{b}}
  </div>
</template>

<style scoped>
</style>

<script>
export default {
	data() {
    return {
      a: 1,
      b: 2,
    }
  },
  mounted() {
    setTimeout(() => {
      // setTimeout 内部，DOM的异步更新方法和 nextTick 回调方法跟代码的顺序一致
      this.$nextTick(() => {
        console.log('?', this.$refs.box.innerHTML) // 1, 2
      })
      this.b = 4
      this.a = 3
    }, 2000)
  },
  beforeUpdate() {
    console.log('beforeUpdate ', this.a)
    console.log('beforeUpdate ', this.b)
  },
  updated() {
    console.log('updated ', this.a)
    console.log('updated ', this.b)
  },
}
</script>
```

## 怪异的 setTimeout

如果不加 `setTimeout` 包裹，`nextTick` 永远都是在 `updated` 钩子之后执行，所以无论设置状态的操作和 nextTick 之间的顺序是什么，nextTick 都能拿到最新的 DOM 内容。

但是加了 setTimeout 就不一样了。

当 `this.a` 在 `this.$nextTick` 之前时，nextTick 能够拿到最新的 DOM。`这个时候，更新 dom 的异步方法先进队列，然后是 beforeUpdate、updated。最后是 nextTick 回调函数进入队列`，所以先执行了 `更新DOM的异步方法`，再执行了 `nextTick callback`

```js
setTimeout(() => {
  this.a = 3
  this.$nextTick(() => {
    console.log('?', this.$refs.box.innerHTML) // 3, 4
  })
  this.b = 4
}, 2000)
```

当 `this.a` 在 `this.$nextTick` 之后时，nextTick 会比 `DOM的更新操作` 先执行。这是因为 `nextTick callback` 先进入队列，`DOM的更新操作`紧随其后，然后是 `beforeUpdate、updated`。所以先执行了 `nextTick callback`，从而拿不到最新的 DOM。

```js
setTimeout(() => {
  this.$nextTick(() => {
    console.log('?', this.$refs.box.innerHTML) // 1, 2
  })
  this.a = 3
  this.b = 4
}, 2000)
```

# 如何提高前端页面的加载速度？

1. 使用路由懒加载、异步组件，实现组件模块的拆分，减少入口文件体积大小

2. 抽离公共代码，采用 splitChunks 进行代码分割

3. 组件加载、脚本模块采用按需加载的方式（`import 方法`）

4. 浏览器缓存策略（HTTP强缓存、协商缓存），缓存静态资源

5. 图片资源的亚索，雪碧图、对小图片采用 base64 减少 HTTP 请求

6. 打包时开启 gzip 压缩处理，`compress-webpack-plugin`

  使用 swc 、esbuild 压缩，提升构建效率

  使用 swc 压缩代码，需要安装 @swc/core 包

  ```js
  optimization: {
    minimize: true, // 开发环境下启用 JS、CSS 优化
    minimizer: [new TerserWebpackPlugin({
      minify: TerserWebpackPlugin.swcMinify,
      terserOptions: {}
    }), new CssMinimizerPlugin()],
    splitChunks: {
      cacheGroups: {
        styles: {
          name: "styles",
          type: "css/mini-extract",
          chunks: "all",
          enforce: true,
        },
      },
      chunks: 'all'
    },
  },
  ```

7. 静态资源采用 CDN 提速